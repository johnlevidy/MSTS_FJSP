Operation scheduling techniques:
Shortest Machining Time (SMT) (greedy)
Largest Remaining Machining Time/Workload (LRMT)
Earliest (Release) Time (ERT)




def get_SMT(operations):
	return min(operations, key=operator.itemgetter(1))


def get_machine_finish_time(op_schedule):
	return max(op_schedule, key=operator.itemgetter(2))


def get_start_time(job_array, operation, machine_graph):
	machine = operation[-2]
	op_schedule = machine_graph.nodes[machine]['op_schedule']
	machine_finish_time = get_machine_finish_time(op_schedule)
	prev_operation = operation[-6]
	if prev_operation = '':
		return machine_finish_time
	elif prev_operation is tuple:
		op_P1_pre = [item for item in job_array if item[1] == prev_operation[0]][0]
		op_P2_pre = [item for item in job_array if item[1] == prev_operation[1]][0]
		operation_finish_time = max(op_P1_pre[-1], op_P2_pre[-1])
		return max(operation_finish_time, machine_finish_time)
	else:
		prev_operation = [item for item in job_array if item[1] == prev_operation][0]
		return max(prev_operation[-1], machine_finish_time)		
		

def schedule_operation(operation, machine_graph, prev_machine, start_time):
	machine = operation[-2]
	op_schedule = machine_graph.nodes[machine]['op_schedule']
	idx = [i for i, tupl in enumerate(op_schedule) if tupl[0] == operation[1]][-1]
	op_tuple = op_schedule[idx]

	if prev_machine == '':
		transition_time = 0
	if prev_machine == machine:
		transition_time = 0
	else:
		transition_time = get_transition_time(machine_graph, machine, prev_machine)

	start_time += transition_time
	finsh_time = calculate_machining_time(operation, machine_graph, machine) + start_time
	op_tuple = (operation[1], start_time, finish_time)
	op_schedule[idx] = op_tuple
	nx.set_node_attributes(machine_graph, {machine: {'op_schedule': op_schedule} } )


def schedule_SMT(jobs_array, machine_graph):
	unscheduled_operations = []
	scheduled_operations = []
	next_executable_operations = []

	for i in range(jobs_array):
		operation = jobs_array[i][0]
		machining_time = calculate_machining_time(operation, machine_graph, operation[-2])
		next_executable_operation.append((operation, machining_time))

	operation = get_SMT(next_executable_operation)

	if operation[6] == '':
		job_array = jobs_array[int(operation[0][1]) - 1]
		start_time = get_start_time(job_array, operation, machine_graph)
		prev_machine = ''
		schedule_operation(operation, machine_graph, prev_machine, start_time)
	elif (operation[6] in scheduled_operations):
		job_array = jobs_array[int(operation[0][1]) - 1]
		start_time = get_start_time(job_array, operation, machine_graph)
		prev_operation = [item for item in job_array if item[1] == operation[6]][0]
		schedule_operation(operation, machine_graph, prev_operation[-2], start_time)
	elif type(operation[6]) is tuple:
		if (operation[6][0] in scheduled_operations) and (operation[6][1] in scheduled_operations):
			job_array = jobs_array[int(operation[0][1]) - 1]
			start_time = get_start_time(job_array, operation, machine_graph)
			op_P1_pre = [item for item in job_array if item[1] == operation[6][0]][0]
			op_P2_pre = [item for item in job_array if item[1] == operation[6][1]][0]

			# GET THE OPERATION WITH MAX FINISH TIME AND THEN CAN CHANGE GET START TIME FUNCTION 
			prev_operation = 
			
			schedule_operation(operation, machine_graph, machine, start_time)
		



		op_P1_pre = [item for item in job_array if item[1] == prev_operation[0]][0]
		op_P2_pre = [item for item in job_array if item[1] == prev_operation[1]][0]
		operation_finish_time = max(op_P1_pre[-1], op_P2_pre[-1])












